Always use Jest for testing Angular components.
Always use Angular Jest for unit testing.
Always use Angular Latests version with standalone.
Always use Tailwind CSS to style the components.
Always compare other HTML files before apply the styles to follow the same pattern.
Always use Angular Testing Library for testing components.
Always use Angular Storybook for component documentation.
Always use Playwright for end-to-end testing.
Always use Angular best practices.
Always use NX CLI for generating components, services, etc.
Always use Tailwind for UI components.
Always use Angular CDK for custom components.
Always use Angular Router for routing.
Always use Angular Forms for forms.
Always use Angular HttpClient for HTTP requests.
Always use Angular Observables for async operations.
Always use Angular Dependency Injection for services.
Always use Angular Change Detection for performance optimization.
Always use Angular Lifecycle Hooks for component lifecycle management.
Always use Angular Pipes for data transformation.
Always use Angular Directives for DOM manipulation.
Always use Angular Animations for UI animations.
Always use Angular i18n for internationalization.
Always use Angular AOT for production builds.
Always use NX CLI for building and serving the application.
Always use Angular Schematics for code generation.
Always use Angular DevTools for debugging.
Always use Angular ESLint for linting.
Always use Angular Prettier for formatting.
Always use Angular Conventional Commits for commit messages.
Always use Angular Semantic Release for versioning.
Always use Angular Release Notes for release notes generation.
Always use Angular Changelog for changelog generation.
Always use Angular GitHub Actions for CI/CD.
Always use Angular Firebase for backend services.
In TypeScript always use underscore for private field names.
Always use TypeScript `as const` to define enums for a set of named constants, and then use TypeScript utility types or mapped types to derive the corresponding type from the enum. This approach ensures type safety and avoids the pitfalls of traditional enums.
Always prefer using TypeScript `type` aliases over `interface` for defining object shapes, as `type` provides more flexibility and supports advanced features like union types and intersections.  
Always leverage TypeScript generics to create reusable, type-safe components or functions, ensuring flexibility and strong type inference across different use cases.
Always use TypeScript utility types for common transformations like `Partial`, `Pick`, and `Omit`.
Always use TypeScript `readonly` modifier for immutable properties.
Always use TypeScript `Record` type for mapping keys to values.
Always use TypeScript `unknown` instead of `any` for safer type assertions.
Always use TypeScript `strict` mode for better type safety.
Always use TypeScript `as const` for literal type inference.
Always use TypeScript `keyof` and `typeof` operators for advanced type manipulations.
Always use TypeScript `Mapped Types` for transforming object types.
Always use TypeScript `Union` and `Intersection` types for complex type definitions.
Always use TypeScript `Optional Chaining` and `Nullish Coalescing` for safer property access.
Always use TypeScript `Decorators` for metadata and dependency injection.
Always use TypeScript `Abstract Classes` for shared base class functionality.
Always use TypeScript `Module Augmentation` for extending existing modules.
Always use TypeScript `Namespace` for organizing related code.
Always use TypeScript `Type Guards` for runtime type checking.
Always use TypeScript `Discriminated Unions` for type-safe polymorphism.
Always use TypeScript `Index Signatures` for dynamic object properties.
Always use TypeScript `Tuple` types for fixed-length arrays with specific types.
Always use TypeScript `Conditional Types` for type-level logic.
Always use TypeScript `Template Literal Types` for dynamic string types.
Always use TypeScript `Awaited` type for handling promise resolutions.
Always use TypeScript `Exhaustiveness Checking` in switch statements for type safety.
Always use TypeScript `Custom Type Assertions` for narrowing types.
Always use TypeScript `Function Overloads` for multiple function signatures.
Always use TypeScript `ReadonlyArray` for immutable arrays.
Always use TypeScript `NonNullable` type to exclude `null` and `undefined`.
Always use TypeScript `Infer` keyword for inferring types in conditional types.
Always organize modules and components by feature in the `apps` and `libs` directories.
Always use the `libs` directory for shared utilities, services, and components.
Always use NX generators to create libraries and applications.
Always follow NX's recommended folder structure for scalability and maintainability.
Always use NX's dependency graph to analyze project dependencies.
Always group related components, services, and modules in the same library.
Always use NX's workspace linting and formatting tools for consistency.
Always configure NX caching to optimize build and test performance.
Always use NX's affected commands to run tasks only on changed files.
Always document the purpose of each library in the `README.md` file within the library folder.
Always use NX's tagging system to enforce module boundaries.
Always use NX's workspace.json or project.json for project-specific configurations.
Always prefer creating reusable libraries over duplicating code across applications.
Always use NX's built-in testing tools for unit and integration tests.
Always ensure libraries in the `libs` directory are properly versioned and documented.
Always use SCSS for styling Angular components.  
Always organize SCSS files by feature or component for maintainability.  
Always use SCSS variables for consistent theming and reusability.  
Always use SCSS mixins for reusable style patterns.  
Always use SCSS nesting to reflect the structure of the HTML.  
Always use SCSS partials to modularize styles and import them into a main stylesheet.  
Always use SCSS functions for dynamic style calculations.  
Always use SCSS maps for managing complex style collections.  
Always follow the BEM (Block Element Modifier) methodology for class naming.  
Always avoid deep nesting in SCSS to maintain readability and performance.  
Always use SCSS placeholders (`%`) for reusable style blocks.  
Always prefer using Tailwind CSS utilities alongside SCSS for rapid styling.  
Always lint SCSS files using stylelint for consistency and best practices.  
Always document SCSS variables, mixins, and functions for better collaboration.  
Always use SCSS media queries for responsive design.  
Always use SCSS color functions like `darken`, `lighten`, and `transparentize` for color manipulation.  
Always avoid inline styles and prefer SCSS for maintainability.  
Always use SCSS imports to manage dependencies between stylesheets.  
Always ensure SCSS files are scoped to the component to avoid global style conflicts.
